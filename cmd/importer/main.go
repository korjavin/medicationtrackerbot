package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"sort"
	"strings"
	"time"
)

// JSON Structure
type ExportData struct {
	Data struct {
		Medications []MedicationLog `json:"medications"`
	} `json:"data"`
}

type MedicationLog struct {
	DisplayText     string  `json:"displayText"`
	Dosage          float64 `json:"dosage"`
	Units           string  `json:"units"`
	Status          string  `json:"status"`        // "Taken", "Skipped" (maybe?)
	ScheduledDate   string  `json:"scheduledDate"` // "2024-12-03 01:20:00 +0100"
	Start           string  `json:"start"`         // Taken Time
	End             string  `json:"end"`
	IsArchived      bool    `json:"isArchived"`
	ScheduledDosage float64 `json:"scheduledDosage"`
}

// Internal aggregation
type AggregatedMed struct {
	Name     string
	Dosage   string
	Archived bool
	FirstLog time.Time
	LastLog  time.Time
	Logs     []MedicationLog
}

func main() {
	inputPath := flag.String("input", "", "Path to JSON export file")
	outputPath := flag.String("output", "import.sql", "Path to output SQL file")
	flag.Parse()

	if *inputPath == "" {
		log.Fatal("Please provide -input <path>")
	}

	// 1. Read JSON
	data, err := os.ReadFile(*inputPath)
	if err != nil {
		log.Fatalf("Failed to read file: %v", err)
	}

	var export ExportData
	if err := json.Unmarshal(data, &export); err != nil {
		log.Fatalf("Failed to parse JSON: %v", err)
	}

	log.Printf("Found %d intake logs", len(export.Data.Medications))

	// 2. Aggregate
	medMap := make(map[string]*AggregatedMed)

	// Date parsing layout: "2006-01-02 15:04:05 -0700"
	layout := "2006-01-02 15:04:05 -0700"

	for _, entry := range export.Data.Medications {
		name := strings.TrimSpace(entry.DisplayText)
		if name == "" {
			continue
		}

		if _, exists := medMap[name]; !exists {
			medMap[name] = &AggregatedMed{
				Name: name,
				Logs: []MedicationLog{},
			}
		}

		agg := medMap[name]
		agg.Logs = append(agg.Logs, entry)

		// Update details from latest log (approx)
		// We'll sort logs later to be sure
	}

	// 3. Process Aggregates
	var sortedNames []string
	for k := range medMap {
		sortedNames = append(sortedNames, k)
	}
	sort.Strings(sortedNames)

	sqlFile, err := os.Create(*outputPath)
	if err != nil {
		log.Fatalf("Failed to create output file: %v", err)
	}
	defer sqlFile.Close()

	writer := io.StringWriter(sqlFile)

	writer.WriteString("-- Import Script generated by MedicationTrackerBot Importer\n")
	writer.WriteString("BEGIN TRANSACTION;\n\n")

	medIDCounter := 1

	for _, name := range sortedNames {
		agg := medMap[name]

		// Function to get time from log (Scheduled or Start)
		getLogTime := func(l MedicationLog) time.Time {
			s := strings.TrimSpace(l.ScheduledDate)
			if s == "" {
				s = strings.TrimSpace(l.Start)
			}
			t, _ := time.Parse(layout, s)
			return t
		}

		// Sort logs by time
		sort.Slice(agg.Logs, func(i, j int) bool {
			return getLogTime(agg.Logs[i]).Before(getLogTime(agg.Logs[j]))
		})

		// Infer attributes
		latestLog := agg.Logs[len(agg.Logs)-1]
		firstLog := agg.Logs[0]

		agg.Name = latestLog.DisplayText

		// Dosage: If "1 count", leave empty as it's not useful information (implies 1 pill).
		// User can fill in "10mg" later.
		if latestLog.Dosage == 1.0 && strings.ToLower(latestLog.Units) == "count" {
			agg.Dosage = ""
		} else {
			agg.Dosage = fmt.Sprintf("%.0f %s", latestLog.Dosage, latestLog.Units)
		}

		agg.Archived = latestLog.IsArchived

		tFirst := getLogTime(firstLog)
		tLast := getLogTime(latestLog)
		if tFirst.IsZero() {
			log.Printf("Warning: Could not determine start date for %s", agg.Name)
		}

		agg.FirstLog = tFirst
		agg.LastLog = tLast

		// Schedule: "As Needed" default for imported, OR infer daily?

		// Infer Schedule
		// Look at the last 30 logs
		recentLogs := agg.Logs
		if len(recentLogs) > 30 {
			recentLogs = recentLogs[len(recentLogs)-30:]
		}

		timeCounts := make(map[string]int)
		for _, l := range recentLogs {
			// Extract HH:MM directly from string "YYYY-MM-DD HH:MM:SS +Offset"
			// This avoids Go parsing it to UTC/Local and checking system timezone.
			// We want the "User's Wall Clock Time" found in the JSON.
			if len(l.ScheduledDate) >= 16 {
				// "2024-12-03 01:20:00" -> index 11 is '0', len 5 -> "01:20"
				timeStr := l.ScheduledDate[11:16]
				timeCounts[timeStr]++
			}
		}

		log.Printf("Med: %s, TimeCounts: %v", agg.Name, timeCounts)

		// Threshold: 1 occurrence is enough if it's the dominant one?
		// Let's take all times that appear in > 20% of the recent logs
		var scheduledTimes []string
		threshold := int(float64(len(recentLogs)) * 0.2)
		if threshold < 1 {
			threshold = 1
		}

		for t, count := range timeCounts {
			if count >= threshold {
				scheduledTimes = append(scheduledTimes, t)
			}
		}
		sort.Strings(scheduledTimes)

		// Construct Schedule JSON
		scheduleJSON := `{"type":"as_needed"}`
		if len(scheduledTimes) > 0 {
			timesBytes, _ := json.Marshal(scheduledTimes)
			scheduleJSON = fmt.Sprintf(`{"type":"daily","times":%s}`, string(timesBytes))
		}

		var endDateSQL string
		if agg.Archived {
			endDateSQL = fmt.Sprintf("'%s'", tLast.Format(time.RFC3339))
		} else {
			endDateSQL = "NULL"
		}
		startDateSQL := fmt.Sprintf("'%s'", tFirst.Format(time.RFC3339))

		// Insert Medication
		// ID, Name, Dosage, Schedule, Archived, StartDate, EndDate
		stmt := fmt.Sprintf("INSERT INTO medications (id, name, dosage, schedule, archived, start_date, end_date) VALUES (%d, '%s', '%s', '%s', %v, %s, %s);\n",
			medIDCounter,
			escapeSQL(agg.Name),
			escapeSQL(agg.Dosage),
			scheduleJSON,
			boolToInt(agg.Archived),
			startDateSQL,
			endDateSQL,
		)
		writer.WriteString(stmt)

		// Insert Intakes
		for _, l := range agg.Logs {
			schedTime, _ := time.Parse(layout, l.ScheduledDate)
			takenTime, _ := time.Parse(layout, l.Start) // Start is taken time

			// Status
			status := "TAKEN"
			if l.Status == "Skipped" {
				status = "MISSED"
			}

			// user_id = 1 (Assuming default admin)

			intakeStmt := fmt.Sprintf("INSERT INTO intake_log (medication_id, user_id, scheduled_at, taken_at, status) VALUES (%d, %d, '%s', '%s', '%s');\n",
				medIDCounter,
				1, // TODO: Make configurable?
				schedTime.Format(time.RFC3339),
				takenTime.Format(time.RFC3339),
				status,
			)
			writer.WriteString(intakeStmt)
		}

		writer.WriteString("\n")
		medIDCounter++
	}

	writer.WriteString("COMMIT;\n")
	log.Printf("Successfully generated import.sql with %d medications", medIDCounter-1)
}

func escapeSQL(s string) string {
	return strings.ReplaceAll(s, "'", "''")
}

func boolToInt(b bool) int {
	if b {
		return 1
	}
	return 0
}
