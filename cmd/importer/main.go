package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"sort"
	"strings"
	"time"
)

// JSON Structure
type ExportData struct {
	Data struct {
		Medications []MedicationLog `json:"medications"`
	} `json:"data"`
}

type MedicationLog struct {
	DisplayText     string  `json:"displayText"`
	Dosage          float64 `json:"dosage"`
	Units           string  `json:"units"`
	Status          string  `json:"status"`        // "Taken", "Skipped" (maybe?)
	ScheduledDate   string  `json:"scheduledDate"` // "2024-12-03 01:20:00 +0100"
	Start           string  `json:"start"`         // Taken Time
	End             string  `json:"end"`
	IsArchived      bool    `json:"isArchived"`
	ScheduledDosage float64 `json:"scheduledDosage"`
}

// Internal aggregation
type AggregatedMed struct {
	Name     string
	Dosage   string
	Archived bool
	FirstLog time.Time
	LastLog  time.Time
	Logs     []MedicationLog
}

func main() {
	inputPath := flag.String("input", "", "Path to JSON export file")
	outputPath := flag.String("output", "import.sql", "Path to output SQL file")
	flag.Parse()

	if *inputPath == "" {
		log.Fatal("Please provide -input <path>")
	}

	// 1. Read JSON
	data, err := os.ReadFile(*inputPath)
	if err != nil {
		log.Fatalf("Failed to read file: %v", err)
	}

	var export ExportData
	if err := json.Unmarshal(data, &export); err != nil {
		log.Fatalf("Failed to parse JSON: %v", err)
	}

	log.Printf("Found %d intake logs", len(export.Data.Medications))

	// 2. Aggregate
	medMap := make(map[string]*AggregatedMed)

	// Date parsing layout: "2006-01-02 15:04:05 -0700"
	layout := "2006-01-02 15:04:05 -0700"

	for _, entry := range export.Data.Medications {
		name := strings.TrimSpace(entry.DisplayText)
		if name == "" {
			continue
		}

		if _, exists := medMap[name]; !exists {
			medMap[name] = &AggregatedMed{
				Name: name,
				Logs: []MedicationLog{},
			}
		}

		agg := medMap[name]
		agg.Logs = append(agg.Logs, entry)

		// Update details from latest log (approx)
		// We'll sort logs later to be sure
	}

	// 3. Process Aggregates
	var sortedNames []string
	for k := range medMap {
		sortedNames = append(sortedNames, k)
	}
	sort.Strings(sortedNames)

	sqlFile, err := os.Create(*outputPath)
	if err != nil {
		log.Fatalf("Failed to create output file: %v", err)
	}
	defer sqlFile.Close()

	writer := io.StringWriter(sqlFile)

	writer.WriteString("-- Import Script generated by MedicationTrackerBot Importer\n")
	writer.WriteString("BEGIN TRANSACTION;\n\n")

	medIDCounter := 1

	for _, name := range sortedNames {
		agg := medMap[name]

		// Sort logs by time (ScheduledDate)
		sort.Slice(agg.Logs, func(i, j int) bool {
			t1, _ := time.Parse(layout, agg.Logs[i].ScheduledDate)
			t2, _ := time.Parse(layout, agg.Logs[j].ScheduledDate)
			return t1.Before(t2)
		})

		// Infer attributes
		latestLog := agg.Logs[len(agg.Logs)-1]
		firstLog := agg.Logs[0]

		agg.Name = latestLog.DisplayText
		agg.Dosage = fmt.Sprintf("%.0f %s", latestLog.Dosage, latestLog.Units) // Simplify
		agg.Archived = latestLog.IsArchived

		tFirst, _ := time.Parse(layout, firstLog.ScheduledDate)
		tLast, _ := time.Parse(layout, latestLog.ScheduledDate)

		agg.FirstLog = tFirst
		agg.LastLog = tLast

		// Schedule: "As Needed" default for imported, OR infer daily?
		// For safety, let's set "As Needed" JSON or a placeholder cron?
		// User mentioned "date_start, date_end".
		// We can set start_date = first log, end_date = last log (if archived).

		var endDateSQL string
		if agg.Archived {
			endDateSQL = fmt.Sprintf("'%s'", tLast.Format(time.RFC3339))
		} else {
			endDateSQL = "NULL"
		}
		startDateSQL := fmt.Sprintf("'%s'", tFirst.Format(time.RFC3339))

		// Insert Medication
		// ID, Name, Dosage, Schedule, Archived, StartDate, EndDate
		scheduleJSON := `{"type":"as_needed"}` // Default

		stmt := fmt.Sprintf("INSERT INTO medications (id, name, dosage, schedule, archived, start_date, end_date) VALUES (%d, '%s', '%s', '%s', %v, %s, %s);\n",
			medIDCounter,
			escapeSQL(agg.Name),
			escapeSQL(agg.Dosage),
			scheduleJSON,
			boolToInt(agg.Archived),
			startDateSQL,
			endDateSQL,
		)
		writer.WriteString(stmt)

		// Insert Intakes
		for _, l := range agg.Logs {
			schedTime, _ := time.Parse(layout, l.ScheduledDate)
			takenTime, _ := time.Parse(layout, l.Start) // Start is taken time

			// Status
			status := "TAKEN"
			if l.Status == "Skipped" {
				status = "MISSED"
			}

			// user_id = 1 (Assuming default admin)

			intakeStmt := fmt.Sprintf("INSERT INTO intake_log (medication_id, user_id, scheduled_at, taken_at, status) VALUES (%d, %d, '%s', '%s', '%s');\n",
				medIDCounter,
				1, // TODO: Make configurable?
				schedTime.Format(time.RFC3339),
				takenTime.Format(time.RFC3339),
				status,
			)
			writer.WriteString(intakeStmt)
		}

		writer.WriteString("\n")
		medIDCounter++
	}

	writer.WriteString("COMMIT;\n")
	log.Printf("Successfully generated import.sql with %d medications", medIDCounter-1)
}

func escapeSQL(s string) string {
	return strings.ReplaceAll(s, "'", "''")
}

func boolToInt(b bool) int {
	if b {
		return 1
	}
	return 0
}
